from math import factorial
from itertools import combinations_with_replacement, groupby
from functools import reduce
'''
Вы едете на конвент по настольным играм. Скорее всего, там будет достаточно жесткая конкуренция и поэтому вы решили 
узнать немного больше о теории вероятности, поскольку вы подозреваете, что в ближайшее время вам придется много раз 
бросать кости .
Обычно, при использовании нескольких кубиков, вы просто кидаете их, а результат суммируете. Для того, чтобы начать 
исследования по вероятности выпадения тех или иных значений игральных костей, напишите функцию, которая принимает на 
вход число кубиков, число сторон на кубике и исследуемый номер, а возвращает вероятность получения заданного значения. 
Результат должен возвращаться с точностью в четыре цифры после запятой - ±0.0001. Например, если вы бросили 2 
шестигранных кубика, вероятность что выпадет 3 составляет 2/36 или 5,56% в процентном соотношении, соответственно ваша 
функция должна вернуть число, записанное как ≈0.0556. В дроби 2/36 числитель, это количество возможных вариаций 
получения числа 3 на двух кубиках (1;2 или 2;1), а знаменатель, это количество возможных комбинаций для 2-х шистигранных 
кубиков (6**2)

Для каждого теста, предполагается, что все кости одинаковы и пронумерованы от 1 и до числа сторон, заданных входными 
данными включительно. Таким образом, 4-сторонний кубик (D4) будет иметь равные шансы на выпадения чисел 1, 2, 3 или 4. 
И эти шансы можно оценить как 1/4. А 20-сторонний кубик (D20) будет иметь равные шансы на выпадение любого числа от 1 
до 20, которые можно оценить как 1/20.
Советы: Будьте осторожны, если вы захотите решить эту задачу путем перебора всех возможных вариаций - вам возможно 
придется очень долго ждать! Например для входных данных (10, 10, 50) - время ожидания может достигать нескольких 
десятков минут! Используйте принцип динамического программирования, например как здесь .
На входе: Три аргумента. Количество кубиков, количество сторон на кубике и исследуемое значение как целые числа.
На выходе: Вероятность получения заданного значения за один бросок игральных костей, как число с плавающей запятой.

Пример:

probability(2, 6, 3) == 0.0556  # на 2-х шестигранных кубиках вероятность выпадения 3 равна  5.56% 
probability(2, 6, 4) == 0.0833
probability(2, 6, 7) == 0.1667
probability(2, 3, 5) == 0.2222  # на 2-х трехгранных  кубиках вероятность выпадения 5 равна  22.22%
probability(2, 3, 7) == 0       # на 2-х трехгранных  кубиках вы можете выкинуть максимум 6 (3;3)
probability(3, 6, 7) == 0.0694
probability(10, 10, 50) == 0.0375

Как это используется: Эта задача иллюстрирует некоторые решения из основ теории вероятностей. Достаточно много событий 
можно охарактеризовать как сочетание других событий.

Предварительные условия
1 ≤ dice_number ≤ 10
2 ≤ sides ≤ 20
0 ≤ target < 1000
'''


def probability(dice_number, sides, target):

    if dice_number * sides < target:
        return 0

    vsego_ishodov = sides ** dice_number
    koli4estvo_ishodov_target = 0

    for i in combinations_with_replacement(range(1, sides + 1), dice_number):
        if sum(i) == target:
            itemCount = [len([k for k in j]) for _, j in groupby(i)]
            koli4estvo_ishodov_target += factorial(len(i)) / reduce(lambda x, y: x * y, map(factorial, itemCount))
    return koli4estvo_ishodov_target/vsego_ishodov


if __name__ == '__main__':
    # These are only used for self-checking and are not necessary for auto-testing
    def almost_equal(checked, correct, significant_digits=4):
        precision = 0.1 ** significant_digits
        return correct - precision < checked < correct + precision

    assert (almost_equal(probability(2, 6, 3), 0.0556)), "Basic example"
    assert (almost_equal(probability(2, 6, 4), 0.0833)), "More points"
    assert (almost_equal(probability(2, 6, 7), 0.1667)), "Maximum for two 6-sided dice"
    assert (almost_equal(probability(2, 3, 5), 0.2222)), "Small dice"
    assert (almost_equal(probability(2, 3, 7), 0.0000)), "Never!"
    assert (almost_equal(probability(3, 6, 7), 0.0694)), "Three dice"
    assert (almost_equal(probability(10, 10, 50), 0.0375)), "Many dice, many sides"

    print("Coding complete? Click 'Check' to review your tests and earn cool rewards!")
