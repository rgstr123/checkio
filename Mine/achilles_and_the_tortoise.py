'''
Допустим, Ахиллес бежит в десять раз быстрее, чем черепаха, и находится позади неё на расстоянии в тысячу шагов.
За то время, за которое Ахиллес пробежит это расстояние, черепаха в ту же сторону проползёт сто шагов.
Когда Ахиллес пробежит сто шагов, черепаха проползёт ещё десять шагов, и так далее.
Процесс будет продолжаться до бесконечности, Ахиллес так никогда и не догонит черепаху.
– приписывается Аристотелю


"Ахилесс и Черепаха" это один из знаменитых Апорий Зенона .
Никола хочет проверить правильность парадокса на практике и собрал двух роботов для этого:
    Ахилеборг (A1 -- быстрый ловкий андроид) и
    Черепахоминатор (T2 -- медленный тяжеловес).

A1 быстрей T2, поэтому T2 стартует на X секунд раньше.
За X секунд T2 проедет t2_speed*X метров.
Цель A1 догнать T2. Сначала ему нужно достичь точки, где был T2 в момент старта A1.
Но за это время T2 уже уехал вперед и A1 нужно достичь следующей точки и так до бесконечности.
В теории парадокс выглядит верно, но на практике A1 легко догоняет T2.
Может у нас получится подсчитать сколько на это уйдет времени.


Даны скорости A1 и T2 в м/с, а ткаже преимущество T2 в секундах.
Подсчитайте время, когда A1 поровняется с T2 (считая от времени старта T2).
Результат должен быть с точностью до 8 знаков.

Входные данные: Три аргумента. Скорость A1 и T2 и преимущество, как целые числа.
Выходные данные: Время, когда A1 догонит T2 (считая от времени старта T2), как число.

Примеры:
chase(6, 3, 2) == 4
chase(10, 1, 10) == 11.11111111

Как это используется: Давайте вспомним математику из школьной программы.
Иногда простая математика легко разбивает все философский парадоксы.

Предусловия:
t2_speed < a1_speed < 343
0 < advantage ≤ 60
'''


def chase(a1_speed, t2_speed, advantage):
    t = (t2_speed * advantage) / (a1_speed - t2_speed)  # Время t, за которое A1 догонит T2 после своего старта
    total_time = advantage + t                          # Общее время, считая от старта T2
    return round(total_time, 8)                         # Возвращаем результат с точностью до 8 знаков


if __name__ == '__main__':
    #These "asserts" using only for self-checking and not necessary for auto-testing
    def almost_equal(checked, correct, significant_digits):
        precision = 0.1 ** significant_digits
        return correct - precision < checked < correct + precision

    assert almost_equal(chase(6, 3, 2), 4, 8), "example"
    assert almost_equal(chase(10, 1, 10), 11.111111111, 8), "long number"