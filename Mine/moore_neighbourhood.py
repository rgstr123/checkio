# coding: utf8

'''
"Животные и растения могут воспроизводить сами себя, но как было недавно показано, машины тоже могут делать себе подобных…… Новые виды из самовоспроизводящих машин будут описаны одной простой механической моделью, без электричества или магнитизма, будут в состоянии работать без надзора и управления"
-- Эдвард Форест Мур

В конечных автоматах, Окрестность Мура содержит восемь клеток, окружающие центральную ячейку двумерной квадратной решетки. Эта область названа в честь Эдварда Ф. Мура, пионера теории конечных автоматов. Существует множество настольных игр с прямоугольной сеткой квадратных ячеек. Для некоторых игр важно знать обстановку в соседних клетках для схемы размещения фишек и стратегии.
У вас имеется позиция для прямоугольного игрового поля, где 1 клетка с фишкой, а 0 пустая. Также есть координатная сетка, в форме строк и столбцов (нумерация с 0). Вы должны определить сколько фишек близко к этой ячейке. Каждая клетка взаимодействует с восьмью соседними (Горизонтально, вертикально, по диагонали);

Для примера возьмем (см. рисунок) такую схему:

((1, 0, 0, 1, 0),
 (0, 1, 0, 0, 0),
 (0, 0, 1, 0, 1),
 (1, 0, 0, 0, 0),
 (0, 0, 1, 0, 0),)

Для первого примера координаты ячейки (1, 2) и мы можем видеть на схеме, что у фишки есть 3 соседа. Для второго примера координаты ячейки (0, 0) и эта ячейка содержит фишку, но мы считаем только соседей поэтому ответ 1.
Входные данные: Три аргумента. Кортеж кортежей с числами (1/0), номер строки и колонки в виде целых чисел.
Выходные данные: Сколько соседей имеет клетка в виде целого числа.

Примеры:

count_neighbours(((1, 0, 0, 1, 0),
                  (0, 1, 0, 0, 0),
                  (0, 0, 1, 0, 1),
                  (1, 0, 0, 0, 0),
                  (0, 0, 1, 0, 0),), 1, 2) == 3
count_neighbours(((1, 0, 0, 1, 0),
                  (0, 1, 0, 0, 0),
                  (0, 0, 1, 0, 1),
                  (1, 0, 0, 0, 0),
                  (0, 0, 1, 0, 0),), 0, 0) == 1


Зачем это нужно: Как уже упоминалось в начале, эта идея может быть полезна для разработки алгоритмов настольных игр. Кроме того, те же самые принципы могут быть полезны для навигационных и геодезических программ.

Предусловия:
3 ≤ len(grid) ≤ 10
all(len(grid[0]) == len(row) for row in grid)
'''


def count_neighbours(grid, row, col):
    NEIGHBORS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),
                 (0, 1), (1, -1), (1, 0), (1, 1))

    count = 0

    for diff in NEIGHBORS:
        n_row = row + diff[0]
        n_col = col + diff[1]
        if 0 <= n_row < len(grid) and 0 <= n_col < len(grid[n_row]):
            if grid[n_row][n_col]:
                count += 1

    return count


if __name__ == '__main__':
    # These "asserts" using only for self-checking and not necessary for auto-testing
    assert count_neighbours(((1, 0, 0, 1, 0),
                             (0, 1, 0, 0, 0),
                             (0, 0, 1, 0, 1),
                             (1, 0, 0, 0, 0),
                             (0, 0, 1, 0, 0),), 1, 2) == 3, "1st example"
    assert count_neighbours(((1, 0, 0, 1, 0),
                             (0, 1, 0, 0, 0),
                             (0, 0, 1, 0, 1),
                             (1, 0, 0, 0, 0),
                             (0, 0, 1, 0, 0),), 0, 0) == 1, "2nd example"
    assert count_neighbours(((1, 1, 1),
                             (1, 1, 1),
                             (1, 1, 1),), 0, 2) == 3, "Dense corner"
    assert count_neighbours(((0, 0, 0),
                             (0, 1, 0),
                             (0, 0, 0),), 1, 1) == 0, "Single"